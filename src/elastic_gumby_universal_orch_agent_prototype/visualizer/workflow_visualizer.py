"""
Workflow Visualizer

This module provides functionality to visualize workflow JSON structures
as colorful ASCII tree diagrams with icons for better visualization.
"""

import json
import re
from datetime import datetime, timezone
from typing import Any, Dict, List

from .base import BaseVisualizer, Colors, Icons


class WorkflowVisualizer(BaseVisualizer):
    """Enhanced class to visualize workflow structures as colorful ASCII trees."""

    def __init__(self, indent_size: int = 4, use_colors: bool = True, use_icons: bool = True):
        """Initialize the visualizer with configurable options.

        Args:
            indent_size: Number of spaces for each indentation level
            use_colors: Whether to use ANSI colors in output
            use_icons: Whether to use Unicode icons in output
        """
        super().__init__(indent_size, use_colors, use_icons)

        # Node type to renderer method mapping for cleaner dispatch
        self.node_renderers = {
            "tool_call": self._render_tool_call,
            "wait_for_event": self._render_wait_for_event,
            "user_input": self._render_user_input,
            "branch": self._render_branch,
            "loop": self._render_loop,
            "sequence": self._render_sequence,
            "parallel": self._render_parallel,
        }

        # Node type to children processor mapping
        self.children_processors = {
            "sequence": self._process_sequence_children,
            "parallel": self._process_parallel_children,
            "branch": self._process_branch_children,
            "loop": self._process_loop_children,
            "wait_for_event": self._process_wait_for_event_children,
        }

    def visualize_workflow(self, workflow: Dict[str, Any]) -> str:
        """Convert a workflow JSON structure to an enhanced ASCII tree representation.

        Args:
            workflow: The workflow JSON structure

        Returns:
            A string containing the enhanced ASCII tree representation
        """
        result = []

        # Add fancy workflow header
        workflow_name = workflow.get("name", "Unnamed Workflow")
        workflow_desc = workflow.get("description", "No description")

        result.append(self._colorize("=" * 80, Colors.WORKFLOW_TITLE))
        result.append(self._colorize(f"WORKFLOW: {workflow_name}", Colors.WORKFLOW_TITLE))
        result.append(self._colorize(f"Description: {workflow_desc}", Colors.DESCRIPTION))
        result.append("")

        # Start building the tree from the root
        root = workflow.get("root", {})
        self._visualize_node(root, result, "", is_last=True)

        result.append("")
        result.append(self._colorize("=" * 80, Colors.WORKFLOW_TITLE))

        return "\n".join(result)

    def save_workflow_visualization(self, workflow: Dict[str, Any], output_file: str) -> None:
        """Save the workflow visualization to a file.
        Args:
            workflow: The workflow JSON structure
            output_file: Path to the output file
        """
        visualization = self.visualize_workflow(workflow)

        # Create clean version for file output (strip ANSI codes)
        clean_visualization = self._strip_ansi_codes(visualization)

        # Add markdown header with timestamp
        md_content = f"""# {self._iconize(Icons.WORKFLOW).strip()}Workflow Visualization
## Universal Orchestration Agent

**Generated:** {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')}

---

```
{clean_visualization}
```

---

*Generated by Universal Transformation Orchestration Agent (UTOA)*
"""
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(md_content)
        print(
            self._colorize(
                f"{self._iconize(Icons.TRUE).strip()} Workflow visualization saved to {output_file}",
                Colors.GREEN,
            )
        )

    def _format_parameters(self, parameters: Dict[str, Any]) -> str:
        """Format tool parameters showing only variable references and summarizing static parameters."""
        if not parameters:
            return ""

        variable_params = []
        static_param_count = 0

        jsonata_pattern = r'^\{\%[\s\S]*\%\}$'
        for key, value in parameters.items():
            if isinstance(value, str):
                # Check if this parameter contains variable references
                if re.fullmatch(jsonata_pattern, value.strip()):
                    # Highlight variables in string values
                    highlighted_value = self._highlight_variables(value)
                    variable_params.append(f"{key}={highlighted_value}")
                else:
                    static_param_count += 1
            else: # value is number, boolean, or None
                static_param_count += 1

        # Build the parameter string
        param_parts = []

        # Add variable parameters (most important)
        if variable_params:
            param_parts.extend(variable_params)

        # Add summary of static parameters
        if static_param_count > 0:
            param_parts.append(f"+ {static_param_count} static param")

        if param_parts:
            return f"({', '.join(param_parts)})"
        else:
            return "(no params)" if len(parameters) == 0 else f"({len(parameters)} static params)"

    def _render_tool_call(self, node: Dict[str, Any], prefix: str, branch: str) -> str:
        """Render a tool_call node."""
        tool_name = node.get("toolName", "unnamed_tool")
        parameters = node.get("parameters", {})
        output_var = node.get("outputVariable", "")

        icon = self._iconize(Icons.TOOL_CALL)
        colored_type = self._colorize("TOOL_CALL", Colors.TOOL_CALL)
        params_str = self._format_parameters(parameters)
        output_str = ""
        if output_var:
            output_text = f"→ {output_var}"
            output_str = f" {self._colorize(output_text, Colors.OUTPUT_VAR)}"

        return f"{prefix}{branch} {icon}{colored_type}: {tool_name}{params_str}{output_str}"

    def _render_wait_for_event(self, node: Dict[str, Any], prefix: str, branch: str) -> str:
        """Render a wait_for_event node."""
        event_source = node.get("eventSource", "")
        event_type = node.get("eventType", "")
        entity_id = node.get("entityId", "")
        output_var = node.get("outputVariable", "")
        timeout = node.get("timeout", "")

        icon = self._iconize(Icons.WAIT_EVENT)
        colored_type = self._colorize("WAIT_EVENT", Colors.WAIT_EVENT)

        event_str = f"{event_source}.{event_type}"
        if entity_id:
            entity_highlighted = self._highlight_variables(str(entity_id))
            event_str += f" on {entity_highlighted}"

        timeout_str = f" (timeout: {timeout}s)" if timeout else ""
        output_str = ""
        if output_var:
            output_text = f"→ {output_var}"
            output_str = f" {self._colorize(output_text, Colors.OUTPUT_VAR)}"

        return f"{prefix}{branch} {icon}{colored_type}: {event_str}{timeout_str}{output_str}"

    def _render_user_input(self, node: Dict[str, Any], prefix: str, branch: str) -> str:
        """Render a user_input node."""
        prompt = node.get("prompt", "No prompt")
        input_type = node.get("inputType", "text")
        output_var = node.get("outputVariable", "")
        options = node.get("options", [])

        icon = self._iconize(Icons.USER_INPUT)
        colored_type = self._colorize("USER_INPUT", Colors.USER_INPUT)

        highlighted_prompt = self._highlight_variables(prompt)

        type_str = f" (Type: {input_type})"
        options_str = f" Options: {options}" if options else ""
        output_str = ""
        if output_var:
            output_text = f"→ {output_var}"
            output_str = f" {self._colorize(output_text, Colors.OUTPUT_VAR)}"

        return f'{prefix}{branch} {icon}{colored_type}: "{highlighted_prompt}"{type_str}{options_str}{output_str}'

    def _render_branch(self, node: Dict[str, Any], prefix: str, branch: str) -> str:
        """Render a branch node."""
        condition = self._format_condition(node.get("condition", {}))

        icon = self._iconize(Icons.BRANCH)
        colored_type = self._colorize("BRANCH", Colors.BRANCH)

        return f"{prefix}{branch} {icon}{colored_type}: {self._iconize(Icons.CONDITION)}{condition}"

    def _render_loop(self, node: Dict[str, Any], prefix: str, branch: str) -> str:
        """Render a loop node."""
        condition = self._format_condition(node.get("condition", {}))
        iteration_var = node.get("iterationVariable", "")

        icon = self._iconize(Icons.LOOP)
        colored_type = self._colorize("LOOP", Colors.LOOP)

        iter_str = f" iter → {iteration_var}" if iteration_var else ""

        return f"{prefix}{branch} {icon}{colored_type}: {self._iconize(Icons.CONDITION)}{condition}{iter_str}"

    def _render_sequence(self, node: Dict[str, Any], prefix: str, branch: str) -> str:
        """Render a sequence node."""
        icon = self._iconize(Icons.SEQUENCE)
        colored_type = self._colorize("SEQUENCE", Colors.SEQUENCE)

        return f"{prefix}{branch} {icon}{colored_type}"

    def _render_parallel(self, node: Dict[str, Any], prefix: str, branch: str) -> str:
        """Render a parallel node."""
        icon = self._iconize(Icons.PARALLEL)
        colored_type = self._colorize("PARALLEL", Colors.PARALLEL)
        max_concurrency = node.get("maxConcurrency", "")
        aggregate_var = node.get("aggregateVariable", "")

        concurrency_str = f" (max: {max_concurrency})" if max_concurrency else ""
        aggregate_str = f" → {aggregate_var}" if aggregate_var else ""

        return f"{prefix}{branch} {icon}{colored_type}{concurrency_str}{aggregate_str}"

    def _process_sequence_children(
        self, node: Dict[str, Any], result: List[str], new_prefix: str
    ) -> None:
        """Process children of a sequence node."""
        steps = node.get("steps", [])
        for i, step in enumerate(steps):
            self._visualize_node(step, result, new_prefix, i == len(steps) - 1)

    def _process_parallel_children(
        self, node: Dict[str, Any], result: List[str], new_prefix: str
    ) -> None:
        """Process children of a parallel node."""
        branches = node.get("branches", [])
        for i, branch_node in enumerate(branches):
            self._visualize_node(branch_node, result, new_prefix, i == len(branches) - 1)

    def _process_branch_children(
        self, node: Dict[str, Any], result: List[str], new_prefix: str
    ) -> None:
        """Process children of a branch node."""
        # Add if_true branch
        if_true = node.get("ifTrue", {})
        true_line = f"{new_prefix}{self.branch_chars['tee']} {self._iconize(Icons.TRUE)}{self._colorize('IF TRUE:', Colors.BRANCH)}"
        result.append(true_line)
        self._visualize_node(
            if_true,
            result,
            new_prefix + self.branch_chars["pipe"] + self.indent_char * (self.indent_size - 1),
            False,
        )

        # Add if_false branch
        if_false = node.get("ifFalse", {})
        false_line = f"{new_prefix}{self.branch_chars['last']} {self._iconize(Icons.FALSE)}{self._colorize('IF FALSE:', Colors.BRANCH)}"
        result.append(false_line)
        self._visualize_node(
            if_false, result, new_prefix + self.indent_char * self.indent_size, True
        )

    def _process_loop_children(
        self, node: Dict[str, Any], result: List[str], new_prefix: str
    ) -> None:
        """Process children of a loop node."""
        body = node.get("body", {})
        body_line = (
            f"{new_prefix}{self.branch_chars['last']} {self._colorize('LOOP BODY:', Colors.LOOP)}"
        )
        result.append(body_line)
        self._visualize_node(body, result, new_prefix + self.indent_char * self.indent_size, True)

    def _process_wait_for_event_children(
        self, node: Dict[str, Any], result: List[str], new_prefix: str
    ) -> None:
        """Process children of a wait_for_event node (onTimeout handler)."""
        on_timeout = node.get("onTimeout", {})
        if on_timeout:
            timeout_line = f"{new_prefix}{self.branch_chars['last']} {self._iconize(Icons.TIMEOUT)}{self._colorize('ON TIMEOUT:', Colors.WAIT_EVENT)}"
            result.append(timeout_line)
            self._visualize_node(
                on_timeout, result, new_prefix + self.indent_char * self.indent_size, True
            )

    def _visualize_node(
        self, node: Dict[str, Any], result: List[str], prefix: str, is_last: bool
    ) -> None:
        """Recursively visualize a node in the workflow - REFACTORED VERSION.

        This method has been refactored to be much cleaner and more maintainable:
        - Uses dictionary dispatch instead of long if-elif chains
        - Separates rendering logic from child processing logic
        - Each node type has its own dedicated render method
        - Much easier to extend with new node types

        Args:
            node: The current node to visualize
            result: The list to append lines to
            prefix: The prefix to use for this line (for indentation)
            is_last: Whether this is the last item in its parent's list
        """
        # Determine the branch character to use
        branch = self.branch_chars["last"] if is_last else self.branch_chars["tee"]

        # Get node type and description
        node_type = node.get("type", "unknown")
        node_desc = node.get("description", "")

        # Render the node using the appropriate renderer (dictionary dispatch)
        if node_type in self.node_renderers:
            line = self.node_renderers[node_type](node, prefix, branch)
        else:
            # Unknown node type
            line = f"{prefix}{branch} {node_type}"

        result.append(line)

        # Add description if present (for containers)
        if node_desc and node_type in ["sequence", "parallel"]:
            desc_prefix = prefix + (
                self.indent_char * self.indent_size
                if is_last
                else self.branch_chars["pipe"] + self.indent_char * (self.indent_size - 1)
            )
            desc_text = f"{self._iconize(Icons.DESCRIPTION)}{node_desc}"
            desc_line = f"{desc_prefix}{self._colorize(desc_text, Colors.DESCRIPTION)}"
            result.append(desc_line)

        # Process children if this node type has children (dictionary dispatch)
        if node_type in self.children_processors:
            # Prepare the new prefix for children
            new_prefix = prefix
            if is_last:
                new_prefix += self.indent_char * self.indent_size
            else:
                new_prefix += self.branch_chars["pipe"] + self.indent_char * (self.indent_size - 1)

            # Process children using the appropriate processor
            self.children_processors[node_type](node, result, new_prefix)

    def _format_condition(self, condition: Dict[str, Any]) -> str:
        """Format a condition object as a readable string with variable highlighting.

        Args:
            condition: The condition object from the workflow

        Returns:
            A string representation of the condition with highlighted variables
        """
        condition_type = condition.get("type", "")

        if condition_type == "comparison":
            left = condition.get("left") or "None"
            operator = condition.get("operator", "")
            right = condition.get("right") or "None"
            # Highlight variables in left and right operands
            left_highlighted = self._highlight_variables(str(left))
            right_highlighted = self._highlight_variables(str(right))

            return f"{left_highlighted} {operator} {right_highlighted}"

        elif condition_type == "logical":
            operator = condition.get("operator", "")
            conditions = condition.get("conditions", [])
            formatted_conditions = [self._format_condition(c) for c in conditions]

            if operator == "not" and formatted_conditions:
                return f"NOT ({formatted_conditions[0]})"
            else:
                return f" {operator.upper()} ".join([f"({c})" for c in formatted_conditions])

        return "Unknown condition"
